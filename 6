from tensorflow.keras.optimizers import Adam
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
import pandas as pd
from keras_visualizer import visualizer
from keras import models, layers
from keras.callbacks import EarlyStopping
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import numpy as np
import pandas as pd
import warnings
warnings.filterwarnings('ignore')


df = pd.read_csv("diabetes.csv")
pandas_df = pd.DataFrame(df)
pandas_df.describe()


X = pandas_df.iloc[:, :-1].values  # Features (all columns except the last one)
y = pandas_df.iloc[:, -1].values   # Labels (last column)

# Scale features for better model performance
scaler = StandardScaler()
X = scaler.fit_transform(X)

# Split data into training and validation sets
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)

# Define the model
model = Sequential()
model.add(Dense(12, input_dim=X.shape[1], activation='relu'))  # Number of input features = X.shape[1]
model.add(Dense(8, activation='relu'))
model.add(Dense(9, activation='relu'))
model.add(Dense(1, activation='sigmoid'))  # Sigmoid for binary classification

# Get learning rate from the user
learning_rate = float(input("Enter the learning rate (e.g., 0.001): "))

# Define optimizer with the user-provided learning rate(for weight update)
optimizer = Adam(learning_rate=learning_rate)

# Compile the model with the custom learning rate
model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=['accuracy'])

# Early stopping to prevent overfitting
early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

# Train model
model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=100, batch_size=10, callbacks=[early_stopping])





visualizer(model, file_format='png', view=True)








# Evaluate model on both training and validation sets together
for dataset, X_data, y_data in [("Training", X_train, y_train), ("Validation", X_val, y_val)]:
    loss, accuracy = model.evaluate(X_data, y_data, verbose=0)
    error = 1 - accuracy
    print(f"{dataset} Accuracy: {accuracy * 100:.2f}%")
    print(f"{dataset} Error: {error * 100:.2f}%\n")

#  Generate predictions for the validation set
y_pred = model.predict(X_val)  # Predict probabilities
y_pred_class = (y_pred > 0.5).astype("int32")  # Convert probabilities to 0/1

#  Print predictions
print("\nPredicted Probabilities (first 10):")
print(y_pred[:10].flatten())

print("\nPredicted Classes (first 10):")
print(y_pred_class[:10].flatten())

print("\nActual Labels (first 10):")
print(y_val[:10])

#  Construct confusion matrix
cm = confusion_matrix(y_val, y_pred_class)

#  Display confusion matrix visually
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=["No Diabetes (0)", "Diabetes (1)"])
disp.plot(cmap='Blues', values_format='d')

plt.title("Confusion Matrix for Validation Set")
plt.show()

# Optionally print numeric confusion matrix
print("\nConfusion Matrix (numeric):")
print(cm)








# Function to get user input
def get_user_input():
    print("Please enter the following details:")
    pregnancies = float(input("Number of pregnancies: "))
    glucose = float(input("Glucose level: "))
    blood_pressure = float(input("Blood pressure: "))
    skin_thickness = float(input("Skin thickness: "))
    insulin = float(input("Insulin level: "))
    bmi = float(input("BMI: "))
    diabetes_pedigree = float(input("Diabetes Pedigree Function: "))
    age = float(input("Age: "))

    # Store inputs in a NumPy array and scale it using the same scaler used for training
    user_data = np.array([[pregnancies, glucose, blood_pressure, skin_thickness,
                           insulin, bmi, diabetes_pedigree, age]])
    user_data = scaler.transform(user_data)  # Scale the input
    return user_data

# Predict whether the user is diabetic or not
def predict_diabetes():
    user_data = get_user_input()
    prediction = model.predict(user_data)

    # Sigmoid output gives a probability, so we threshold at 0.5
    if prediction >= 0.5:
        print("The model predicts that you are diabetic.")
    else:
        print("The model predicts that you are not diabetic.")

# Call the prediction function
predict_diabetes()
